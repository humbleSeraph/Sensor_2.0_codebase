/************************

This is a module to initialize the PIC16LF1827 to communicate with
the Nokia 5110 graphical LCD screen. I'm going to draw something. 

author: Osagie Igbeare

adapted from code by Jim Lindblom, who adapted code from Nathan Seidle and
"mish-mashed" with code from the ColorLCDSheild

8/7/2014

*************************/

/******************* Pin Configuration *************

 Nokia 5110 LCD ----- < > ----- PIC16LF1827
    1-Vcc       ---------------     3.3V
    2-GND       ---------------     GND
    3-SCE       ---------------     RB5
    4-RST       ---------------     RA0
    5-D/C       ---------------     RB3
    6-DN(MOSI)  ---------------     RB2
    7-SCLK      ---------------     RB4
    8-LED       - 330 ohm res -     3.3V

 ***************************************************/

/**************** Header Files *********************/

#include "BitDefs.h"
//#include <htc.h>          // for HI Tech C compiler
#include <xc.h>
#include "pic.h"
#include "chip_select.h"



/***************** Configuration Macros ***************/

//__CONFIG(FCMEN_OFF & IESO_OFF & FOSC_LP & WDTE_OFF & MCLRE_ON & PWRTE_OFF & BOREN_OFF
//		& LVP_ON & WRT_OFF & CPD_OFF & CP_OFF);

// #pragma config statements should precede project file includes.
// Use project enums instead of #define for ON and OFF.

// CONFIG1
#pragma config FOSC = LP        // Oscillator Selection (LP Oscillator, Low-power crystal connected between OSC1 and OSC2 pins)
#pragma config WDTE = OFF       // Watchdog Timer Enable (WDT disabled)
#pragma config PWRTE = OFF      // Power-up Timer Enable (PWRT disabled)
#pragma config MCLRE = ON       // MCLR Pin Function Select (MCLR/VPP pin function is MCLR)
#pragma config CP = OFF         // Flash Program Memory Code Protection (Program memory code protection is disabled)
#pragma config CPD = OFF        // Data Memory Code Protection (Data memory code protection is disabled)
#pragma config BOREN = OFF      // Brown-out Reset Enable (Brown-out Reset disabled)
#pragma config CLKOUTEN = ON    // Clock Out Enable (CLKOUT function is enabled on the CLKOUT pin)
#pragma config IESO = OFF       // Internal/External Switchover (Internal/External Switchover mode is disabled)
#pragma config FCMEN = OFF      // Fail-Safe Clock Monitor Enable (Fail-Safe Clock Monitor is disabled)

// CONFIG2
#pragma config WRT = OFF        // Flash Memory Self-Write Protection (Write protection off)
#pragma config PLLEN = OFF      // PLL Enable (4x PLL disabled)
#pragma config STVREN = ON      // Stack Overflow/Underflow Reset Enable (Stack Overflow or Underflow will cause a Reset)
#pragma config BORV = LO        // Brown-out Reset Voltage Selection (Brown-out Reset Voltage (Vbor), low trip point selected.)
#pragma config LVP = ON         // Low-Voltage Programming Enable (Low-voltage programming enabled)


/***************** # Defines *****************/
#define lcd_data BIT3HI
#define lcd_command BIT3LO
#define hangTime 1000

#define LCD_Width 84        //x coordinates go wide
#define LCD_Height 31       //y coordinates go high
#define WHITE 0             // for drawing individual pixels, 0 draws white
#define BLACK 1             // see above, 1 draws black

/*************** module level variables ************/

static char counter; 
int x;
int i = 0; 
static char LCD_Init[6];


/********* Shout out to Jim Lindblom for the data sructures below ********/
/************************************************************************/

/* FONT TABLE:

  This table contains the hex values that represent pixels for a
  font that is 5 pixels wide and 8 pixels high. Each byte in a row
  represents one, 8-pixel, vertical column of a character. 5 bytes
  per character. */

 
  static const char ASCII[][5] = {
    // First 32 characters (0x00-0x19) are ignored. These are
    // non-displayable, control characters.
     {0x00, 0x00, 0x00, 0x00, 0x00} // 0x20
    ,{0x00, 0x00, 0x5f, 0x00, 0x00} // 0x21 !
    ,{0x00, 0x07, 0x00, 0x07, 0x00} // 0x22 "
    ,{0x14, 0x7f, 0x14, 0x7f, 0x14} // 0x23 #
    ,{0x24, 0x2a, 0x7f, 0x2a, 0x12} // 0x24 $
    ,{0x23, 0x13, 0x08, 0x64, 0x62} // 0x25 %
    ,{0x36, 0x49, 0x55, 0x22, 0x50} // 0x26 &
    ,{0x00, 0x05, 0x03, 0x00, 0x00} // 0x27 '
    ,{0x00, 0x1c, 0x22, 0x41, 0x00} // 0x28 (
    ,{0x00, 0x41, 0x22, 0x1c, 0x00} // 0x29 )
    ,{0x14, 0x08, 0x3e, 0x08, 0x14} // 0x2a *
    ,{0x08, 0x08, 0x3e, 0x08, 0x08} // 0x2b +
    ,{0x00, 0x50, 0x30, 0x00, 0x00} // 0x2c ,
    ,{0x08, 0x08, 0x08, 0x08, 0x08} // 0x2d -
    ,{0x00, 0x60, 0x60, 0x00, 0x00} // 0x2e .
    ,{0x20, 0x10, 0x08, 0x04, 0x02} // 0x2f /
    ,{0x3e, 0x51, 0x49, 0x45, 0x3e} // 0x30 0
    ,{0x00, 0x42, 0x7f, 0x40, 0x00} // 0x31 1
    ,{0x42, 0x61, 0x51, 0x49, 0x46} // 0x32 2
    ,{0x21, 0x41, 0x45, 0x4b, 0x31} // 0x33 3
    ,{0x18, 0x14, 0x12, 0x7f, 0x10} // 0x34 4
    ,{0x27, 0x45, 0x45, 0x45, 0x39} // 0x35 5
    ,{0x3c, 0x4a, 0x49, 0x49, 0x30} // 0x36 6
    ,{0x01, 0x71, 0x09, 0x05, 0x03} // 0x37 7
    ,{0x36, 0x49, 0x49, 0x49, 0x36} // 0x38 8
    ,{0x06, 0x49, 0x49, 0x29, 0x1e} // 0x39 9
    ,{0x00, 0x36, 0x36, 0x00, 0x00} // 0x3a :
    ,{0x00, 0x56, 0x36, 0x00, 0x00} // 0x3b ;
    ,{0x08, 0x14, 0x22, 0x41, 0x00} // 0x3c <
    ,{0x14, 0x14, 0x14, 0x14, 0x14} // 0x3d =
    ,{0x00, 0x41, 0x22, 0x14, 0x08} // 0x3e >
    ,{0x02, 0x01, 0x51, 0x09, 0x06} // 0x3f ?
    ,{0x32, 0x49, 0x79, 0x41, 0x3e} // 0x40 @
    ,{0x7e, 0x11, 0x11, 0x11, 0x7e} // 0x41 A
    ,{0x7f, 0x49, 0x49, 0x49, 0x36} // 0x42 B
    ,{0x3e, 0x41, 0x41, 0x41, 0x22} // 0x43 C
    ,{0x7f, 0x41, 0x41, 0x22, 0x1c} // 0x44 D
    ,{0x7f, 0x49, 0x49, 0x49, 0x41} // 0x45 E
    ,{0x7f, 0x09, 0x09, 0x09, 0x01} // 0x46 F
    ,{0x3e, 0x41, 0x49, 0x49, 0x7a} // 0x47 G
    ,{0x7f, 0x08, 0x08, 0x08, 0x7f} // 0x48 H
    ,{0x00, 0x41, 0x7f, 0x41, 0x00} // 0x49 I
    ,{0x20, 0x40, 0x41, 0x3f, 0x01} // 0x4a J
    ,{0x7f, 0x08, 0x14, 0x22, 0x41} // 0x4b K
    ,{0x7f, 0x40, 0x40, 0x40, 0x40} // 0x4c L
    ,{0x7f, 0x02, 0x0c, 0x02, 0x7f} // 0x4d M
    ,{0x7f, 0x04, 0x08, 0x10, 0x7f} // 0x4e N
    ,{0x3e, 0x41, 0x41, 0x41, 0x3e} // 0x4f O
    ,{0x7f, 0x09, 0x09, 0x09, 0x06} // 0x50 P
    ,{0x3e, 0x41, 0x51, 0x21, 0x5e} // 0x51 Q
    ,{0x7f, 0x09, 0x19, 0x29, 0x46} // 0x52 R
    ,{0x46, 0x49, 0x49, 0x49, 0x31} // 0x53 S
    ,{0x01, 0x01, 0x7f, 0x01, 0x01} // 0x54 T
    ,{0x3f, 0x40, 0x40, 0x40, 0x3f} // 0x55 U
    ,{0x1f, 0x20, 0x40, 0x20, 0x1f} // 0x56 V
    ,{0x3f, 0x40, 0x38, 0x40, 0x3f} // 0x57 W
    ,{0x63, 0x14, 0x08, 0x14, 0x63} // 0x58 X
    ,{0x07, 0x08, 0x70, 0x08, 0x07} // 0x59 Y
    ,{0x61, 0x51, 0x49, 0x45, 0x43} // 0x5a Z
    ,{0x00, 0x7f, 0x41, 0x41, 0x00} // 0x5b [
    ,{0x02, 0x04, 0x08, 0x10, 0x20} // 0x5c \
    ,{0x00, 0x41, 0x41, 0x7f, 0x00} // 0x5d ]
    ,{0x00, 0x41, 0x41, 0x7f, 0x00} // 0x5d ]
    ,{0x04, 0x02, 0x01, 0x02, 0x04} // 0x5e ^
    ,{0x40, 0x40, 0x40, 0x40, 0x40} // 0x5f _
    ,{0x00, 0x01, 0x02, 0x04, 0x00} // 0x60 `
    ,{0x20, 0x54, 0x54, 0x54, 0x78} // 0x61 a
    ,{0x7f, 0x48, 0x44, 0x44, 0x38} // 0x62 b
    ,{0x38, 0x44, 0x44, 0x44, 0x20} // 0x63 c
    ,{0x38, 0x44, 0x44, 0x48, 0x7f} // 0x64 d
    ,{0x38, 0x54, 0x54, 0x54, 0x18} // 0x65 e
    ,{0x08, 0x7e, 0x09, 0x01, 0x02} // 0x66 f
    ,{0x0c, 0x52, 0x52, 0x52, 0x3e} // 0x67 g
    ,{0x7f, 0x08, 0x04, 0x04, 0x78} // 0x68 h
    ,{0x00, 0x44, 0x7d, 0x40, 0x00} // 0x69 i
    ,{0x20, 0x40, 0x44, 0x3d, 0x00} // 0x6a j
    ,{0x7f, 0x10, 0x28, 0x44, 0x00} // 0x6b k
    ,{0x00, 0x41, 0x7f, 0x40, 0x00} // 0x6c l
    ,{0x7c, 0x04, 0x18, 0x04, 0x78} // 0x6d m
    ,{0x7c, 0x08, 0x04, 0x04, 0x78} // 0x6e n
    ,{0x38, 0x44, 0x44, 0x44, 0x38} // 0x6f o
    ,{0x7c, 0x14, 0x14, 0x14, 0x08} // 0x70 p
    ,{0x08, 0x14, 0x14, 0x18, 0x7c} // 0x71 q
    ,{0x7c, 0x08, 0x04, 0x04, 0x08} // 0x72 r
    ,{0x48, 0x54, 0x54, 0x54, 0x20} // 0x73 s
    ,{0x04, 0x3f, 0x44, 0x40, 0x20} // 0x74 t
    ,{0x3c, 0x40, 0x40, 0x20, 0x7c} // 0x75 u
    ,{0x1c, 0x20, 0x40, 0x20, 0x1c} // 0x76 v
    ,{0x3c, 0x40, 0x30, 0x40, 0x3c} // 0x77 w
    ,{0x44, 0x28, 0x10, 0x28, 0x44} // 0x78 x
    ,{0x0c, 0x50, 0x50, 0x50, 0x3c} // 0x79 y
    ,{0x44, 0x64, 0x54, 0x4c, 0x44} // 0x7a z
    ,{0x00, 0x08, 0x36, 0x41, 0x00} // 0x7b {
    ,{0x00, 0x00, 0x7f, 0x00, 0x00} // 0x7c |
    ,{0x00, 0x41, 0x36, 0x08, 0x00} // 0x7d }
    ,{0x10, 0x08, 0x08, 0x10, 0x08} // 0x7e ~
    ,{0x78, 0x46, 0x41, 0x46, 0x78} // 0x7f DEL
  };
 

  /* The displayMap variable stores a buffer representation of the
  pixels on our display. There are 504 total bits in this array,
  same as how many pixels there are on a 84 x 48 display.

  Each byte in this array covers a 8-pixel vertical block on the
  display. Each successive byte covers the next 8-pixel column over
  until you reach the right-edge of the display and step down 8 rows.

  To update the display, we first have to write to this array, then
  call the updateDisplay() function, which sends this whole array
  to the PCD8544.

  Because the PCD8544 won't let us write individual pixels at a
  time, this is how we can make targeted changes to the display. */

  char displayMap[LCD_Width * LCD_Height / 8] = {
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // (0,0)->(11,7) ~ These 12 bytes cover an 8x12 block in the left corner of the display
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // (12,0)->(23,7)
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xE0, // (24,0)->(35,7)
    0xF0, 0xF8, 0xFC, 0xFC, 0xFE, 0xFE, 0xFE, 0xFE, 0x1E, 0x0E, 0x02, 0x00, // (36,0)->(47,7)
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // (48,0)->(59,7)
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // (60,0)->(71,7)
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // (72,0)->(83,7)
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // (0,8)->(11,15)
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // (12,8)->(23,15)
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, // (24,8)->(35,15)
    0x0F, 0x1F, 0x3F, 0x7F, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFE, 0xFC, 0xF8, // (36,8)->(47,15)
    0xF8, 0xF0, 0xF8, 0xFE, 0xFE, 0xFC, 0xF8, 0xE0, 0x00, 0x00, 0x00, 0x00, // (48,8)->(59,15)
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // (60,8)->(71,15)
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // (72,8)->(83,15)
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // (0,16)->(11,23)
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // (12,16)->(23,23)
    0x00, 0x00, 0xF8, 0xFC, 0xFE, 0xFE, 0xFF, 0xFF, 0xF3, 0xE0, 0xE0, 0xC0, // (24,16)->(35,23)
    0xC0, 0xC0, 0xE0, 0xE0, 0xF1, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, // (36,16)->(47,23)
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x3E, 0x00, 0x00, 0x00, // (48,16)->(59,23)
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // (60,16)->(71,23)
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // (72,16)->(83,23)
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // (0,24)->(11,31)
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // (12,24)->(23,31)
    0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, // (24,24)->(35,31)
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, // (36,24)->(47,31)
    0xFF, 0xFF, 0xFF, 0x7F, 0x3F, 0x1F, 0x07, 0x01, 0x00, 0x00, 0x00, 0x00, // (48,24)->(59,31)
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // (60,24)->(71,31)
  };

 // PIC16LF1827 only has 386 bytes of RAM, this array alone is 506 bytes, so I'm using only 64% of it
// until I get the LF1825 which has over 1K in memory :-P. (.64 = 324 entries of the original 504)
/*
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // (72,24)->(83,31)
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // (0,32)->(11,39)
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // (12,32)->(23,39)
    0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x7F, 0x3F, 0x1F, // (24,32)->(35,39)
    0x0F, 0x0F, 0x0F, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x03, 0x03, // (36,32)->(47,39)
    0x01, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // (48,32)->(59,39)
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // (60,32)->(71,39)
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // (72,32)->(83,39)
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // (0,40)->(11,47)
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // (12,40)->(23,47)
    0x00, 0x00, 0x3F, 0x1F, 0x0F, 0x07, 0x03, 0x01, 0x00, 0x00, 0x00, 0x00, // (24,40)->(35,47)
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // (36,40)->(47,47)
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // (48,40)->(59,47)
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // (60,40)->(71,47)
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // (72,40)->(83,47) !!! The bottom right pixel!
  };
 */


/********* Function Prototypes ***************/

void InitPorts(void);
void InitTimers(void);
void InitInterrupts(void);
void InitComm(void);
void NokiaInit(void);
void Delay(int waitTime); 
void SightPin_B0(void);
void sendByte(char type, char byte);
void updateDisplay(void);
void gotoPixel(int x, int y);
//void eraseDisplay();
void Example(); 




/******* Acutal Functions ****************/

void InitPorts()
{

	ANSELA = 0x00;			// Port A pins are digital
	ANSELB = 0x00;			// Port B pins are digital

	TRISA = 0b00000000;		// 1 - input, 0 - output, RA2, RA0 are outputs
	TRISB = 0b00000010;		// 1 - input, 0 - output, RB0, RB2 - RB6 is an output

	PORTA = 0b11111110;             //RA0 - low
	PORTB = 0b11111111;

	APFCON0 = 0x00;
        //OSCCON = 0x00;
	
}

void InitTimers()
{

	T2CON = 0b01111110;		// Fosc / (4 instruct * 16 prescale * 16 postscale * 60 PR2) = 65 Hz
	PR2 = 1;
}

void InitInterrupts()
{

	PIE1 = 0b00000010; 		// Enable TMR2IE, interrupt when Timer 2 matches PR2
					// Enable SSP1IE, interrupt for MSSP1 (aka SPI1)
					// Bit 3 high - enable MSSP interrupt 	
	INTCON = 0b11000000;	// Enable GIE, Enable PEIE
	
}


void InitComm()
{
	// setup SPI-1 (aka SSP) to communicate with Nokia LCD screen

	SSP1ADD = 2;			// Baud Rate = Fosc / ((SSP1ADD + 1)(4))
							// since Fosc = 4 MHz, Baud Rate = 1 MHz
							// since SSP1ADD = 0 is not supported same timing is achieved
							// by setting bits <3:0> of SSPM all to 0's (see below)

	SSP1STATbits.SMP = 0;				// data on rising edge, data @ middle
	SSP1CON1bits.WCOL = 0; 	 			// no collision
	SSP1CON1bits.SSPOV = 0; 			// no overflow
	SSP1CON1bits.SSPEN = 1; 			// SSP Enable

	SSP1CON1bits.CKP = 1; 				// idle high 
	SSP1STATbits.CKE = 0;				// sample ? edges 

	SSP1CON1bits.SSPM3 =  0;			// Set LF1827 as Master, clock rate Fosc / 4
	SSP1CON1bits.SSPM2 = 0;
	SSP1CON1bits.SSPM1 = 0; 
	SSP1CON1bits.SSPM0 = 0; 

}


void interrupt ISR()
{
	counter++;
	if (TMR2IF)
	{
		if ((counter % 2) != 0)
		{
			PORTA |= BIT2HI;

		}
		else
		{
			PORTA &= BIT2LO;
			counter = 0;
		}

		TMR2IF = 0;		// clears the TIMR2IF (timer 2 interrupt flag)

	}

}

void NokiaInit()
{

	//i = 0;
	// LCD_Init array populated with initialization sequence

	LCD_Init[0] = 0x21;			// tell LCD extended commands to 
	LCD_Init[1] = 0xE0;			// set LCD Vop (contrast) ** parameter to mess with if screen doesn't display ****
	LCD_Init[2] = 0x04;			// set temp coefficient
	LCD_Init[3] = 0x13;			// LCD Bias mode 1:48 (if not working, try 0x13)
	LCD_Init[4] = 0x20;			// back to regular commands
	LCD_Init[5] = 0x0C;			// enable normal display (dark on light), horiz addressing


	// initialization sequence for the PCD8544 driver on the Nokia LCD
	// starting off with RESET
	
	PORTA &= BIT0LO;
	Delay(hangTime); 
	PORTA |= BIT0HI;

        // the rest of the initialization sequence
	
	//PORTB &= lcd_command;           // tell LCD commands are coming
	
	PORTB &= BIT5LO;		// lower SCE line to begin transmission
	
	for (i=0; i<6; i++)             // sending 6 commands to the LCD screen
	{
		sendByte(lcd_command, LCD_Init[i]);
	}	

	PORTB |= BIT5HI;		// raising SCE line at the end of transmission0
}

void Delay(int waitTime)
{
	x = 0;
	while(x < waitTime)
	{
            x += 1;
	}
}

void sendByte (char type, char byte)
{
        PORTB &= type;           // tell the LCD commands are coming

        PIR1bits.SSP1IF = 0;

	SSP1BUF = byte; 

	while (!SSP1STATbits.BF); 


}

void updateDisplay()
{
    gotoPixel(0,0);
    for (int j=0; j<(LCD_Width*LCD_Height / 8); j++)
    {
        sendByte(lcd_data, displayMap[j]);
    }
}

void gotoPixel(int x, int y)
{
    sendByte(lcd_command, 0x80 | x);        // column
    sendByte(lcd_command, 0x40 | y);        // row
}

void setContrast(char contrast)
{
    PORTB &= BIT5LO;

    sendByte(lcd_command, 0x21);
    sendByte(lcd_command, 0x80 | contrast);
    sendByte(lcd_command, 0x20);

    PORTB |= BIT5HI; 


}

void Example()
{

    sendByte(lcd_data, 0x07);
    sendByte(lcd_data, 0x00);
}

/***********************************************************/
/******************** Debugging Library ********************/

void SightPin_B0(void)
{
	// toggles pin B0 for debugging purposes
	if ((PORTB & BIT0HI) == BIT0HI)
	{
		PORTB &= BIT0LO;

	}
	else
	{
		PORTB |= BIT0HI; 
	}

}


/********************************************************/
/******** Main - which actually runs the code ***********/
/********************************************************/

void main ()
{

	// Initializing PIC16LF1827
	InitPorts();
	InitTimers();
	InitInterrupts();
	InitComm(); 
	NokiaInit();
	while(1)
	{
            
            PORTB &= BIT5LO;
            updateDisplay();
            setContrast(50);
            PORTB |= BIT5HI;
            Delay(30000);
           
            /*
            PORTB &= BIT5LO;
            Example();
            setContrast(50);
            PORTB |= BIT5HI;
            Delay(30000);
            */

            NokiaInit(); 
	}



}


